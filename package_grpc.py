#!/usr/bin/python3
"""Generates a python package from auto-generated gRPC python source protocols"""
import subprocess
from pathlib import Path
import sys
import re
import argparse
import warnings
import shutil
import os
import glob
from datetime import datetime
import tempfile
import string
import random


def random_string(stringLength=10):
    """Generate a random string of fixed length """
    letters = string.ascii_lowercase
    return ''.join(random.choice(letters) for i in range(stringLength))


def random_tmp_path():
    """Create a temporary path within the temp directory"""
    tmpdir = tempfile.gettempdir()
    rndpath = os.path.join(tmpdir, random_string(10))
    os.mkdir(rndpath)
    return rndpath


def parse_version(version):
    """Expects a version string like "0.2.0" and returns a tuple of ints"""
    try:
        ver_maj, ver_min, ver_pat = [int(val) for val in version.split('.')]
    except (ValueError, AttributeError):
        raise ValueError('Invalid version string "%s".  ' % str(version) +
                         'Needs to be "major.minor.patch" like "0.1.0"')
    return ver_maj, ver_min, ver_pat


# generic readme
README = """### {:s} gRPC Protocols

This Python package contains the auto-generated gRPC python protocols.

Version: {:s}
Auto-generated on: {:s}

"""

SETUP = """\"""Installation file for the {0:s} package\"""
from setuptools import setup

install_requires = ['grpcio',
                    'google-api-python-client',
                    'protobuf']

setup(
    name='{0:s}',
    packages=[{1:s}],
    version='{3:s}',
    license='MIT',
    url='https://github.com/pyansys/protos-mapdl',
    maintainer_email='alexander.kaszynski@ansys.com',
    description='Package for {0:s} python gRPC client built on {2:s}',
    python_requires='>=3.5.*',
    install_requires=install_requires,
)
"""

VERSON = """\"""{:s} python protocol version\"""
__version__ = '{:d}.{:d}.{:d}'  # major.minor.patch
"""


def build_python_grpc(protos_path):
    """Builds *.py source interface files given a path containing *.protos files"""
    os.environ['PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION'] = 'cpp'
    rndpath = random_tmp_path()

    # check for protos at the protos path
    proto_glob = os.path.join(protos_path, '*.proto')
    files = glob.glob(proto_glob, recursive=True)
    if not files:
        raise FileNotFoundError(f'Unable locate any *.proto files at {protos_path}')

    # verify proto tools are installed
    try:
        import grpc_tools
    except:
        raise ImportError('Missing grpc_tools.  Install with `pip install grpc_tools`')

    cmd = f'python -m grpc_tools.protoc -I{protos_path} '
    cmd += f'--python_out={rndpath} --grpc_python_out={rndpath} {proto_glob}'

    if os.system(cmd):
        raise RuntimeError(f'Failed to run:\n\n{cmd}')

    # verify something was built
    files = glob.glob(os.path.join(rndpath, '*.py'), recursive=True)
    if not files:
        raise RuntimeError(f'No python source generated at {rndpath}')

    return rndpath


def package_grpc(protos_path, package_name, wheel=False):
    """Package auto-generated grpc python client protocols

    Parameters
    ----------
    protos_path : str
        This is the gRPC source path containing autogenerated gRPC
        python source files.

    package_name : str
        Package name.  Must be a python vaild package name for example
        ``"dpf"``.  All packages will be prepended with `ansys-grpc-`

    Examples
    --------
    >>> package_grpc('protos', 'mapdl')
    """
    version_file = os.path.join(protos_path, 'VERSION')
    if not os.path.isfile(version_file):
        raise FileNotFoundError(f'VERSION file not found at {version_file}')

    with open(version_file) as f:
        version_str = f.read().strip()
        ver_maj, ver_min, ver_pat = parse_version(version_str)

    # compile the protocols
    grpc_source_path = build_python_grpc(protos_path)

    # check valid package name
    if not package_name.isidentifier():
        raise ValueError('Invalid python package name "%s"' % package_name)
    elif package_name.lower() != package_name:
        warnings.warn('Package name should be all lowercase')

    # core_package_name = package_name
    package_name = 'ansys-grpc-%s' % package_name

    # grab all module names and source
    py_glob = os.path.join(grpc_source_path, '*.py')
    grpc_source_files = glob.glob(py_glob, recursive=True)
    py_source = {}
    for filename in grpc_source_files:
        relative_path = filename.replace(grpc_source_path, '')
        module_name = '.'.join(re.split(r'\\|/', relative_path))
        module_name = module_name.replace('.py', '')
        module_name = module_name.strip('.')
        py_source[module_name] = open(filename).read()

    # Replace all imports for each module with an absolute import with
    # the new full module name

    # For example
    # import base_pb2 as base__pb2
    # becomes...
    # import ansys.grpc.dpf.base_pb2 as base__pb2
    packages = set()
    for relative_module_name in py_source:
        # package may be a nested package
        if '.' in relative_module_name:
            package_paths = relative_module_name.split('.')
            module_name = package_paths[-1]
            parsed_package = package_name.replace('-', '.')
            this_package_name = '%s.%s' % (parsed_package, *package_paths[:-1])
        else:
            # otherwise, it's on the root level
            module_name = relative_module_name
            parsed_package = package_name.replace('-', '.')
            this_package_name = parsed_package

        find_str = 'import %s' % module_name
        repl_str = 'import %s.%s' % (this_package_name, module_name)
        packages.add(this_package_name)

        # search through all modules
        for mod_name, mod_source in py_source.items():
            py_source[mod_name] = mod_source.replace(find_str, repl_str)

    # create a temp directory for the python module
    package_path = random_tmp_path()

    # write setup file
    now_str = datetime.now().strftime("%H:%M:%S on %d %B %Y")
    setup_file_path = os.path.join(package_path, 'setup.py')
    with open(setup_file_path, 'w') as f:
        packages_str = ', '.join(["'%s'" % package for package in packages])
        f.write(SETUP.format(package_name, packages_str, now_str, version_str))

    # write readme file
    readme_file_path = os.path.join(package_path, 'README.md')
    with open(readme_file_path, 'w') as f:
        f.write(README.format(package_name, version_str, now_str))

    # create package source dir
    split_package_name = package_name.split('-')
    package_source_path = os.path.join(package_path, *split_package_name)
    os.makedirs(package_source_path)

    # write init file
    init_file_path = os.path.join(package_source_path, '__init__.py')
    with open(init_file_path, 'w') as f:
        f.write('from %s._version import __version__' % package_name.replace('-', '.'))

    # write version file
    ver_file_path = os.path.join(package_source_path, '_version.py')
    with open(ver_file_path, 'w') as f:
        f.write(VERSON.format(package_name, ver_maj, ver_min, ver_pat))

    # write python source
    for module_name, module_source in py_source.items():
        relative_module_path = module_name.split('.')
        relative_module_path[-1] = '%s.py' % relative_module_path[-1]
        filename = os.path.join(package_source_path, *relative_module_path)

        # path may not exist
        module_dir = os.path.dirname(filename)
        if not os.path.isdir(module_dir):
            os.makedirs(module_dir)
            # must create an init file in new directory
            Path(os.path.join(module_dir, '__init__.py')).touch()

        with open(filename, 'w') as f:
            f.write(module_source)

    if wheel:
        btype = 'bdist_wheel'
    else:
        btype = 'sdist'

    p = subprocess.Popen(f"{sys.executable} setup.py {btype}",
                         stdout=subprocess.PIPE,
                         shell=True,
                         cwd=package_path)
    print(p.stdout.read().decode())

    dist_dir = os.path.join(os.getcwd(), 'dist')
    if not os.path.isdir(dist_dir):
        os.mkdir(dist_dir)

    if wheel:
        whl_glob = os.path.join(package_path, 'dist', '*.whl')
        whl_files = glob.glob(whl_glob)
        if not whl_files:
            raise FileNotFoundError(f'Wheel not created at {package_path}')
        if len(whl_files) != 1:
            raise RuntimeError('Multiple wheel files generated')
        dist_file = whl_files[0]
    else:
        dist_glob = os.path.join(package_path, 'dist', '*.tar.gz')
        dist_files = glob.glob(dist_glob)
        if not dist_files:
            raise FileNotFoundError(f'Source distribution not created at {package_path}')
        if len(dist_files) != 1:
            raise RuntimeError('Source distribution files generated')
        dist_file = dist_files[0]

    tgt_pth = os.path.join(dist_dir, os.path.basename(dist_file))
    final_pth = shutil.move(dist_file, tgt_pth)
    print(f'Built python package for {package_name} at:\n{final_pth}')


def main():
    """Package auto-generated grpc python client protocols

    Package name will be ansys-grpc-<the protocols directory>

    For example: "ansys-grpc-mapdl"

    Expects there to be a VERSION file at the root directory
    containing the protocols.

    Examples
    --------
    $ python package_grpc.py protos
    """
    parser = argparse.ArgumentParser(description='package_grpc')
    parser.add_argument('grpc_source_path', type=str,
                        help='Path containing auto-generated gRPC python protocol')

    args = parser.parse_args()
    package_name = args.grpc_source_path
    package_grpc(args.grpc_source_path, package_name)


if __name__ == '__main__':
    main()
